import BaseComponent from '../../baseComponent';
import ElementWithComponent from '../../ElementWithComponent';
import Box from '../../atoms/box';

const BOX_MARGIN: number = 48;
const MEDIA_MAX_WIDTH_568PX: string = '(max-width: 568px)';
const DISABLED_CLASS: string = '--disabled';

class Lightbox extends BaseComponent {

  protected static events = [
    'collapse',
    'closeClicked',
    'next',
    'back',
    'backgroundClicked',
    'show',
  ];

  /**
   * the underlying box component
   */
  private box: Box;

  /**
   * Index of currently shown image
   */
  private currentIndex: number = 0;

  /**
   * returns a valid lightbox ID to place into the modal box for the given string
   */
  public static lightboxId = (id: string): string =>
    `frontend-kit-lightbox-${id}`;


  /**
   * finds a lightbox with the given ID
   */
  public static findLightbox = (
    id: string,
  ): ElementWithComponent<Lightbox> | null =>
    document.getElementById(Lightbox.lightboxId(id)) as ElementWithComponent<
      Lightbox
    >;

  /**
   * shows the modal with the given modal ID, if it exists
   */
  public static showLightbox = (id: string): void => {
    const lightboxElement = Lightbox.findLightbox(id);

    if (!lightboxElement) {
      console.warn(`Could not find a lightbox with id ${id} to show.`);
    } else {
      lightboxElement.component.show();
    }
  };

  /**
   * hides the modal with the given modal ID, if it exists
   */
  public static hideLightbox = (id: string): void => {
    const lightboxElement = Lightbox.findLightbox(id);

    if (!lightboxElement) {
      console.warn(`Could not find a lightbox with id ${id} to hide.`);
    } else {
      lightboxElement.component.hide();
    }
  };

  /**
   * An array of images used in the lightbox
   */
  private readonly images: NodeListOf<Element>;
  /**
   * A counter element
   */
  private readonly counter: HTMLElement;
  /**
   * A next button element
   */
  private readonly nextButton: HTMLElement;
  /**
   * A back button element
   */
  private readonly backButton: HTMLElement;
  /**
   * A close button element
   */
  private readonly closeButton: HTMLElement;
  /**
   * A collapse button element
   */
  private readonly collapseButton: HTMLElement;

  constructor(container: HTMLElement) {
    super(container);

    this.images = container.querySelectorAll('.a-image');
    this.counter = container.querySelector('.m-lightbox__controlBar__counter');
    this.closeButton = container.querySelector('[data-frok-action="close"]');
    
    this.nextButton = container.querySelector(
      '[class*="m-lightbox__controlBar__nextBtn"]',
    );
    
    this.backButton = container.querySelector(
      '[class*="m-lightbox__controlBar__backBtn"]',
    );

    this.collapseButton = container.querySelector(
      '[class*="m-lightbox__controlBar__collapseBtn__"]',
    ); 

    this.images.forEach((image: HTMLElement, index: number) => {
      this.showImageAndCaption(index, index === 0);

      if (this.collapseButton instanceof HTMLElement) {
        const imageCaption = image.querySelector('figcaption');

        if (imageCaption instanceof Element) {
          // Show and hide collapsed text on click
          const expandClass: string = 'm-lightbox__controlBar__collapseBtn__expand';
          const collapseClass: string = 'm-lightbox__controlBar__collapseBtn__collapse';
          this.collapseButton.addEventListener('click', (event) => {
            if (imageCaption.classList.contains('collapsed')) {
              this.collapseButton.classList.replace(
                collapseClass,
                expandClass,
              );

              imageCaption.classList.replace('collapsed', 'expanded');
            } else {
              this.collapseButton.classList.replace(
                expandClass,
                collapseClass,
              );

              this.showImageAndCaption(index, index === this.currentIndex);
              
              imageCaption.classList.replace('expanded', 'collapsed');
            }
            this.triggerEvent('collapse');
          });

          this.setLightboxSize();

          // image captions are collapsed as default
          imageCaption.classList.add('collapsed');
        }
      }
    });

    // Set Up Image sequence
    if (this.nextButton instanceof HTMLElement) {
      this.nextButton.addEventListener('click', () => {
        this.next();
        this.triggerEvent('next');
      });
    }

    if (this.backButton instanceof HTMLElement) {
      this.backButton.addEventListener('click', () => {
        this.back();
        this.triggerEvent('back');
      });
    }

    // close Button
    if (this.closeButton instanceof HTMLElement) {
      this.closeButton.addEventListener('click', () => {
        this.hide();
        this.triggerEvent('closeClicked');
      });
    }

    // setup box sub-component
    const boxElement = container.querySelector('.a-box, .a-box--modal');

    if (boxElement) {
      this.box = new Box(boxElement as HTMLElement);

      if (this.box.isModal()) {
        // move to the end as well
        document.body.appendChild(container);
        // and move the box back into here
        container.appendChild(boxElement);
      }

      this.box.addEventListener('backgroundClicked', () =>
        this.triggerEvent('backgroundClicked'),
      );

    } else {
      throw new Error(
        'Dialog is missing a box, please check your dialog markup',
      );
    }
  }

  private showImageAndCaption = (imageIndex: number, visibility: boolean): void => {
    const image = this.images[imageIndex];
    const caption = image.querySelector('figcaption');

    if (image instanceof HTMLElement) {
      image.style.display = visibility ? 'block' : 'none';
    }

    if (caption instanceof HTMLElement) {
      if (window.matchMedia(MEDIA_MAX_WIDTH_568PX).matches) {
        const ratioWrapper: HTMLElement = image.querySelector('.a-image__ratioWrapper');
        ratioWrapper.style.height = 'auto';
      }
    }
  };

  private setArrowState = (): void => {
    const backBtnEnabled = this.currentIndex === 0;
    this.backButton.firstElementChild.classList.replace(
      `m-lightbox__controlBar__back${backBtnEnabled ? '' : DISABLED_CLASS}`,
      `m-lightbox__controlBar__back${backBtnEnabled ? DISABLED_CLASS : ''}`,
    );

    const nextBtnEnabled = this.currentIndex + 1 === this.images.length;
    this.nextButton.firstElementChild.classList.replace(
      `m-lightbox__controlBar__next${nextBtnEnabled ? '' : DISABLED_CLASS}`,
      `m-lightbox__controlBar__next${nextBtnEnabled ? DISABLED_CLASS : ''}`,
    );
  };

  /**
   * Calculates the aspect ratio of the Lightbox with all elements (closeBar, image, caption, controlBar)
   * and set the css properties based on this ratio. Therefore, height and width scaling of lightbox is possible.
   */
  private setLightboxSize() {
    const image: HTMLElement = this.images[this.currentIndex].querySelector('.a-image__ratioWrapper');
    const box: HTMLElement = this.container.querySelector('.a-box');
    const closeBar: HTMLElement = this.container.querySelector('.m-lightbox__closeBar');
    const controlBar: HTMLElement = this.container.querySelector('.m-lightbox__controlBar');
    const figcaption: HTMLElement = this.container.querySelector('figcaption');

    const imgHeight = image.clientHeight;

    const width = image.clientWidth;
    var height = imgHeight + closeBar.clientHeight;

    if (this.needsControlBar()){
      height = height + controlBar.clientHeight;
    }

    if (figcaption){
      height = height + figcaption.clientHeight;
    }

    const ratio = (width as any as number) / (height as any as number);
    const heightRatio = 100 / ratio;
    const maxHeightRatio = 100 * ratio;

    
    if (box instanceof HTMLElement){
      box.style.width =  `calc(100vw - ${BOX_MARGIN}px)`;
      box.style.height =  `calc(${heightRatio}vw - ${BOX_MARGIN}px)`;
      box.style.maxWidth =  `calc(${maxHeightRatio}vh - ${BOX_MARGIN}px)`;
      box.style.maxHeight =  `calc(100vh - ${BOX_MARGIN}px)`;
    }
  }

  private next = (): void => {
    if (this.currentIndex + 1 !== this.images.length) {
      this.showImageAndCaption(this.currentIndex, false);
      this.currentIndex += 1;
      this.showImageAndCaption(this.currentIndex, true);

      this.counter.innerHTML = `${this.currentIndex + 1} of ${this.images.length}`;

      this.showOrHideCollapseBtn();

      this.setArrowState();
    }
  };

  private back = (): void => {
    if (this.currentIndex !== 0) {
      this.showImageAndCaption(this.currentIndex, false);
      this.currentIndex -= 1;
      this.showImageAndCaption(this.currentIndex, true);

      this.counter.innerHTML = `${this.currentIndex + 1} of ${this.images.length}`;

      this.showOrHideCollapseBtn();

      this.setArrowState();
    }
  };

  /**
   * shows this dialog
   */
  public show(): void {
    this.box.show();

    this.showOrHideCollapseBtn();

    // remove control bar if not needed
    const controlBar = this.container.querySelector('.m-lightbox__controlBar');
    if (controlBar instanceof HTMLElement) {
      if (this.needsControlBar()) {
        controlBar.style.display = 'flex';
      }
      else {
        controlBar.style.display = 'none'; 
        this.container.querySelectorAll('figcaption').forEach(caption => {
          caption.style.bottom = '0';
        });
      }
    }

    if (!window.matchMedia(MEDIA_MAX_WIDTH_568PX).matches) {
      this.setLightboxSize();
    }

    // on defined media queries in css file, the Lightbox resizing based on aspect ratio should not be applied
    window.addEventListener('resize', () => {
      if (window.matchMedia(MEDIA_MAX_WIDTH_568PX).matches) {
        const box = this.container.querySelector('.a-box');
        if (box instanceof HTMLElement){
          box.style.removeProperty('width');
          box.style.removeProperty('height');
          box.style.removeProperty('max-width');
          box.style.removeProperty('max-height');
        }
      } else {
        this.setLightboxSize();
      }
    });
  }

  /**
   * hides this dialog
   */
  public hide(): void {
    this.box.hide();
  }

  /**
   * Checks the sizes of the image caption and return true if the text needs to be expandable
   */
  private hasExpandableCaption(): boolean {
    const imageCaption = this.images[this.currentIndex].querySelector(
      'figcaption',
    );

    if(!imageCaption) {
      return false;
    }

    const expandButton = this.container.querySelector(
      '.m-lightbox__controlBar__collapseBtn__expand',
    );

    return (
      imageCaption.clientHeight < imageCaption.scrollHeight ||
      (expandButton instanceof HTMLElement)
    );
  }

  /**
   * Hides Collapse button if not needed and shows it if it is needed for current image index
   */
  private showOrHideCollapseBtn(): void {
    const imageCaption = this.images[this.currentIndex].querySelector(
      'figcaption',
    );
    const collapseButton = this.container.querySelector(
      '[class*="m-lightbox__controlBar__collapseBtn__"]',
    );

    if (collapseButton instanceof HTMLElement) {
      if (
        imageCaption &&
        imageCaption.innerHTML.length > 0 &&
        this.hasExpandableCaption()
      ) {
        collapseButton.style.display = 'block';
      } else {
        collapseButton.style.display = 'none';
      }
    }
  }

  /**
   * checks if lightbox needs a controlbar with the current image number, collapse, next and back buttons.
   */
  private needsControlBar(): boolean {
    const images = this.container.querySelectorAll('.a-image');
    const imageCaptions = this.container.querySelectorAll('figcaption');

    if (images.length > 1) {
      return true;
    }
    if (!imageCaptions) {
      return false;
    }

    
    return this.hasExpandableCaption();
  }

}

export default Lightbox;
